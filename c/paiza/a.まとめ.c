〇文字と文字列
・''が文字、""が文字列
・文字の配列が文字列、つまり文字列は全て配列
・文字列は必ず'\0'で終わる、""で文字列を宣言すると、自動的に'\0'が付与される
・strcpy(変数, 文字列);を使用すると、文字列を変数に代入出来る


〇ポインタ
・引数にポインタを使用する場合はそのまま紐づけされる、それ以内の場合は、 pointer = hensu;で紐づけが必要
・ポインタを使用すると関数外のデータも変更できる(変数先のアドレスのデータを直接変更するため)
・引数で使用した場合 *pointer : 参照受け渡し <> hensu : 値渡し
・使用する際、ポインタの先のデータを変更する場合は * をつけて、それ以外の場合は * を付けずに使う
・使用した後はポインタでスコープした先のアドレスの開放、ポインタだったアドレスへの NULL 挿入が必要
・配列はポインタ
～宣言～
*pointer = &hensu;

～引数～
void kansu(*pointer)
{
}

kansu(&hensu);

～関係性～
*pointer: &hensu


〇スコープ
・変数を宣言した階層以下の階層で使用出来る
・例: for で宣言した変数は、その for の中で宣言した for では使用できるが、for の外では同じ関数内でも使用できない


〇宣言
～変数～
データ型 変数;
データ型 変数 = 値;
データ型 変数 = {値1, 値2} // 構造体と配列、この値自体が配列の時もある

～関数～
データ型 関数名(引数のデータ型 引数)
{
  return 値;
}

～構造対データ～
struct 構造体名 {
  データ型 値名;
};


〇関数
・データ型はreturnで返す値のデータ型
・返す値がない場合はvoidを設定すると、自動的に return 0;を返す
・return を返すと関数が終了する

～関数の定義～
データ型 関数名(引数のデータ型 引数)
{
  処理;
  return 値;
}


〇構造体
・struct 構造体名 これがこの構造体のデータ型名になる
・typedef を使う事で、データ型に名前を付けられる
～宣言～
struct 構造体名 {
  データ型 値名1;
  データ型 値名2;
};

typedef {
  データ型 値名;
} データ型名;

～宣言時～
データ型名 変数名 = {値1, 値2..., 値n};

～使用～
変数名.値名
変数名->値名  //ポインタの時


〇構造体と関数
・以下の場合、返り値としてデータの並びが帰る
Datatype kansu
{
  Datatype hensu; // 宣言
  hensu.value1 = 値1; // 値を代入;
  hensu.value2 = 値2;

  return hensu;
}
return -> {値1, 値2}  // 値の並びが返る


〇スタック
・一時保存する配列(data[])と、data[]の最後の要素+1の位置を指し示すsizeの組合わせ
・sizeが常に最後の要素+1になるように、push関数とpop関数を作成
・データを追加するときはdata[size]の位置に追加して、size変数を1足す
・データを取るときはdata[size-1]の位置からデータを取り出して、sizeを1引く
～データをpush～
push(追加するデータ);

～データをpop～
データ型 *p;
pop(&p);
pを使った処理;


〇キュー
・一時保存する配列(data[])と、data[]の最初の要素の位置を示すheadと、data[]の最後の要路+1を示すtailの組合わせ
・tailは配列の最後までいったら先頭に戻るようにする
・headは常にデータの先頭にあるようにして、tailはhead-1を超えないようにする
