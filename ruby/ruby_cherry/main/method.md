## 説明
- 対象にhashが含まれているものは、構造体にも仕様できる

## 取得系
- `class`レシーバーのクラスを調べる
  - レシーバー.class
- `methods` 対象のクラスが持つメソッドを調べる
- `ancestors` 自身のクラス, モジュール, スーパークラスの配列を返す
  - メソッドの探索順が分かるため、superの利用に便利


## 実行系
- `eval()` 引数の文字列を、rubyコマンドとして実行する
- `send()` レシーバーに対して、引数の文字列orシンボルのメソッドを実行する


## 真偽系
- `nil?`
- `odd?`
- `include?()` 引数が含まれているか
- `has_key?`, `key?`, `include?`, `member` 引数のキーがhashに含まれているかどうか
- `all?{|block|}` ループ処理を実行して、戻り値が全て真ならtrue
- `is-a?` is-aの関係かどうか調べる


## 計算系
- `round()` 引数の桁になるように四捨五入する
  - 正の数が小数点第何位か、負の数-1, -2, -3が1, 10, 100に対応している
- `divmod()` 商と余りを配列で返す
  - 割られる数.divmod(割る数) => [商, 余り]


## 文字列, 正規表現系
### 文字列操作
- `rjust(, )` 桁を揃える
  - 対象.rjust(桁数, 埋める文字)
  - '3'.rjust(3, '0') => "003"

- `gsub(, )` 対象の文字列を、第一引数を第二引数にreplaceした文字列を返す
  - !で破壊
  - 第二引数で、キャプチャを参照する際は\番号
  - `\k<name>` 名前付きキャプチャの場合は\k<name>で参照出来る
  - 他にも色々出来る、ググれ

- `slice!()` 対象を中から引数にマッチする部分を破壊的に削除
  - キャプチャした場合、第二引数必須、キャプチャの何番目を削除するか指定する
  - 名前付きキャプチャの場合、第二引数をkeyで指定する

- `match()` 指定した正規表現(または文字列)にマッチしたMatchDataを返す
  - StrまたはReg.match(RegまたはStr) => [マッチ結果, キャプチャ1, キャプチャ2...]
  - 配列と同じようにデータを取得出来る(result[1] => キャプチャ1の中身)
  - ?<name>を使用することで、ハッシュのようにキャプチャにkeyを割り振る事が可能
  ```ruby
  text = "私の誕生日は1997年7月17日です"
  data = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
  data #=> #<MatchData "1997年7月17日" year:"1997" month:"7" day:"17">
  data[:year] #=> "1997"
  data[1] #=> "1997" 連番でも指定できる
  ```
- `sprintf(, )` 指定したフォーマットの文字列生成
  - sprintf('フォーマット指定子', 対象) => フォーマットに沿った対象の文字列

### 取得
- `scan()` 文字列を分割して配列を返す
  - 対象.scan(正規表現、または部分文字列)
  - 引数とマッチした箇所が配列で返る
  - キャプチャしていた場合、キャプチャ箇所が配列化した2次元配列で返る
  ```ruby
  '12ab34'.scan(/../) => ["12", "ab", "34"]
  ```

- `slice()` 文字列の中から引数にマッチした部分を取得
  - []のエイリアスメソッド
  - キャプチャした場合、第二引数必須、キャプチャの何番目を削除するか指定する
  - 名前付きキャプチャの場合、第二引数をkeyで指定する
### 分割
- `chars` 文字列を1文字ずつ分割して配列にする

- `split()` 文字列を引数の文字を区切りとして区切って、配列にする
  - "apple,orange,berry".split(',') => ["apple", "orange", "berry"]
  - 正規表現のorで、区切り文字を複数指定可能


## 処理系
- `times{}` レシーバーの数だけループ処理をする
  - ブロック引数を渡すと、それが0からスタートする
- `upto(), downto(), step()` レシーバーの数から引数の数まで処理をループされる
  - ブロック引数はindex番号で、初期値はレシーバー
  - stepは、第二引数で、加減値を設定出来る
  - サンプル
```
  a = []; 2.upto(4){ |n| a << n } => a == [2, 3, 4]
```


## 配列/hash系
### 非ループ 操作
- `delete()` 対象から特定の値/keyを全て削除して整列する
  - 破壊
  - 対象.delete(値/key)
  - ブロックを渡すと、見つからなかった時の戻り値を設定できる
    - 対象.delete(値/key) { |値/key| "#{値/key}は見つかりませんでした" }

### 非ループ 配列のみ
- `grep()` 配列の中から引数を含んだ物を返す

- `index()` 引数の値のindex番号を取ってくる

- `join()` 配列を連結させた文字列の生成
  - 配列.join('区切り文字')

- `values_at()` 引数の添え字部分だけを配列として作成
  - 配列のみ対象
  - 配列.values_at(添え字, 添え字...)

- `delete_at()` 配列の特定の箇所を削除して整列する
  - 破壊
  - 配列のみ対象
  - 配列.delete_at(添え字)
  - 戻り値は削除した値

### 非ループ hashのみ
- `keys`, `values` key/valueをそれぞれ配列に入れて返す
- `merge()` レシーバーの中に引数のhashを混ぜる

### ループ 再編
- `delete_if{}` 配列を順番に参照して、処理の最終的な真偽が真なら削除、最後に整列
  - 配列のみ対象
  - 破壊
  - 配列.delete_if do |ブロック|; 処理; end

- `select{}` 戻り値がtrueになる要素を集め(falseになる要素を削除)、最終的に残った物を戻り値として返す
  - !で破壊
  - 配列.select do |ブロック|; 処理; end
  - falseバージョンにrejectがある

- `map{}` 戻り値を順に新しい配列に格納していき、最終的に生成された配列を返す
  - !で破壊
  - 配列.map do |ブロック|; 処理; end
  - hashに対して使っても、戻り値は配列

### ループ 取得
- `find{}` 最初に戻り値が真になった要素を戻り値として返す
  - ブロック
  - 配列.find { |block| 処理 }

### ループ 処理
- `each{}` いつもの

- `inject(){}` たたみ込み算をする
  - 引数が初期値、第一ブロックが足されていく数、第二ブロックがそのループの対象データ
  - 対象: 配列, hash
  - 引数, ブロック*2
  - 対象.inject(引数) { |block1, block2| block1に対する計算処理 } => ブロック1の最終的な値
  - 記述しなくても、処理に対して自動的に block1 = が追加されて、block1 = 処理 として計算される
  - 文字列にも使用可能

- `with_index(){}` indexを追加
  - ループ処理メソッドをレシーバーとすることで、その処理に、index番号を表す第二ブロック引数を追加、引数はindexの初期値
  - 対象: 配列, hash
  - 引数, ブロック
  - 対象.each等.with_index(indexの初期値) do |eachのブロック, index番号|; indexは1ループごとに+=1される; end
  - 元のメソッドのブロック引数が複数ある場合、そのブロック引数を()でくくる必要がある
