## 記述
- `begin` `rescue` beginに例外が起きうる処理、rescueに例外処理を記述する
  - `rescue 例外オブジェクト名` 特定の例外オブジェクトのみ例外処理を実行
  - `rescue => 変数` 例外オブジェクトの取得
     - rescueを複数書いたり、例外オブジェクトを複数指定する事も可能
  - `ensure` 例外が起きても起きなくても必ず実行する処理
  - `else` 例外が起きなかった時の処理(あまり使わない)
  - メソッド内の処理全てがbeginに含まれている場合、begin endは省略可能
```ruby
begin
  例外が起きうる処理
rescue
  例外処理
ensure
  例外が起きても起きなくても実行される
end
```
- `retry` 例外処理をやり直す
  - ネットワークエラー等の対策用、カウンタを用意して、数回処理を繰り返すのが一般的
- `raise` 例外(Error)を発生させる
  - 第一引数に文字列を渡す => RuntimeError: "arg"
  - 第二引数に文字列、第一引数にError内容 => arg1Error: "arg2"
  - そのほかに、Errorのクラス.new(メッセージ)のインスタンスを渡すことも可能
- `修飾子` として使う
  - 対象のエラーを指定できない
  ``` ruby
  beginに含む処理 rescue 戻り値
  ```

## 挙動
- エラーが発生した際は、メソッドを1つ1つさかのぼり、rescue文を見つけ次第そこから先を実行する
  - rescue文が二つあった場合、先に見つけた方のみ実行する
- 例外オブジェクトを指定した時は、そのサブクラスまでも指定したことになる
  - NameErrorを指定した際、NoMethodErrorもスコープされる(NoMethodErrorを指定した場合はNameErrorは含まれない)
  - その為、rescue文は、スコープの狭い順に書かないと意味がない
- 例外オブジェクトの継承関係については、337p
- 例外処理にも戻り値がある

## 例外オブジェクト
### 仕様
- エラーの種類毎に、それぞれの例外オブジェクトが存在する(NoMethodError, ZeroDivisionError)

### メソッド
- `message` エラー内容の文字列を取得
- `backtrace` バックトレースを表示
- その他、Objectクラス等のメソッドも扱える

## ベストプラクティス
### 有効な使い方
- `rescue` 一つの例外のために、他の多くの処理が中断されてしまうのを防ぐ
  - ループ処理等
- `raise` 予定していない値が渡された時に、そのまま処理が実行されるのを防ぐ
  - caseやifのelseの先

### 注意点
- 条件が絞り込める際は、条件分岐を使う
- そもそもrescueはあまり使わない方がよい
  - 予期せぬ不具合を招く
- 例外処理が起きたすぐのところでログを残す
- 例外処理のスコープを極力絞り込む
- ensureを書かずに済む場合は書かない方が良い
  - Fileのclose処理などは、ブロックをopenメソッドに渡すと自動で実行される

### その他
- Error系のクラスを継承して、独自のエラークラスを定義する事も可能
