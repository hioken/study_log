# CoreBasic
## 基礎
| 名称                | 説明                                                                                   |
|----------------------------------|---------------------------------------------------------------------------------------|
| 暗黙的な型変換 (implicit type coercion)        | 違う型同士で演算を行う際、型変換が行われる                                 |
| ホイスティング (Hoisting)        | ver変数や関数宣言を最初にメモリ内に保存(スコープの先頭に持ち上げる)。                                 |
| プロトタイプチェーン (Prototype Chain) | オブジェクトが他のオブジェクトを継承し、プロパティやメソッドを共有する仕組み。               |
| thisバインディング (this Binding) | 呼び出し方により`this`が何を指すかが変わるJavaScript特有の仕組み。                      |
| 即時実行関数 (IIFE: Immediately Invoked Function Expression) | 定義と同時に実行される関数で、スコープ汚染を防ぐ用途で使われる。                       |
| 厳格モード (Strict Mode)          | `use strict`でエラーチェックを厳密にし、曖昧な挙動を防ぐモード。                        |
| グローバルオブジェクト (Global Object) | 環境ごとに異なるが、ブラウザでは`window`、Node.jsでは`global`として存在。               |
| グローバル汚染 (Global Pollution) | 不要なグローバル変数やオブジェクトを追加して競合やバグを引き起こす問題。                 |
| カリー化 (Currying)               | 関数の引数を部分適用する形で分割し、順次呼び出す形で実行するテクニック。                  |
| コンテキスト (Execution Context)  | コードが実行される環境情報で、`グローバル`、`関数`、`eval`の3種類がある。               |
| イベントバブリング (Event Bubbling) | DOMイベントが子要素から親要素へ伝播する挙動。`stopPropagation`で制御可能。              |

## 非同期関連
| 名称                | 説明                                                                                   |
|----------------------------------|---------------------------------------------------------------------------------------|
| 非同期処理 (Asynchronous Processing) | タスクを並行して処理する仕組み。代表的な手法はコールバック、`Promise`、`async/await`。     |
| イベントループ (Event Loop)       | 非同期処理を管理する仕組み。タスクキューからイベントを順次取り出して処理。               |
| コールバック (Callback)           | 非同期タスク完了時に実行する関数。ネストが深くなりやすく、`Promise`で置き換え可能。        |
| プロミス (Promise)                | 非同期処理の状態を管理するオブジェクト。`pending`、`fulfilled`、`rejected`の3状態を持つ。  |
| async/await                      | `Promise`を使った非同期処理を同期的な記述で書ける構文。                                 |
| マイクロタスク (Microtask)        | 非同期処理のタスクキューより優先度の高いタスク。`Promise`の処理が該当。                  |
| タスクキュー (Task Queue)         | イベントループで処理される非同期タスクが順番に格納されるキュー。                        |

## グローバルオブジェクト
### 概要
- グローバルオブジェクトは、JavaScriptのどのスコープからもアクセス可能な特別なオブジェクト。
- ビルトインオブジェクト（例: `Object`, `Array`）やグローバル関数（例: `setTimeout`, `console`）を管理する。
- 環境ごとに異なる形で提供される。
  - ブラウザ環境: `window`（または `globalThis`）
  - Node.js環境 `global`（または `globalThis`）

### 仕様
- トップレベルに定義した関数とvar変数(非推奨)は、グローバルオブジェクトのプロパティとして登録される
- グローバルオブジェクトの参照はRubyのクラス参照に似ている
  - Rubyでは、全てのトップレベルのコードが`Object`クラスに囲まれているように、JavaScriptではすべてのトップレベルコードがグローバルオブジェクト（例: `window`）に囲まれていると捉えられる。
  - ブラウザ上のJavaScriptで`window`を参照するのは、Rubyでクラス内から自分自身のクラスを呼び出す感覚に近い。
    - 例えば、Rubyのクラス内で`self`を使う感覚で、JavaScriptではグローバルオブジェクト（ブラウザでは`window`）を参照できる。
  - 例えば、`const window = {};`で囲まれたコード内で`window`を利用しているようなイメージ。

### `globalThis`の利用
- ECMAScript 2020（ES11）で導入。
- 環境に依存せず、グローバルオブジェクトを参照可能。

```javascript
globalThis.myValue = 42;
console.log(globalThis.myValue); // 42
```

# Basic
## Scope
### 順序
1. グローバルスコープ
2. スクリプトスコープ
3. ブロックスコープ, 関数スコープ

### ブロックスコープ
- Jsでは`{}`でスコープを区切る事ができる

### 参照範囲
- Jsでは外部(レキシカルLexical)スコープが参照可能
- そのスコープで参照しようとした変数や関数がない場合、一つ外のスコープを参照する
  - つまり同名の定義がされていた場合、より内側のスコープのものが参照される

## グローバルオブジェクト
## 変数
### 種類
| 特徴              | const                                      | let                               |
|-------------------|--------------------------------------------|-----------------------------------|
| **再代入**        | 不可                                       | 可能                              |
| **再宣言**        | 不可                                       | 不可                              |
| **初期化**        | 必須                                      | 不要                      |
| **値の変更**      | 不可(参照型の内部変更は可能)                     | 値そのものを自由に変更可能        |
| **スコープ**      | ブロックスコープ（{}内で有効）              | ブロックスコープ（{}内で有効）     |
### TDZ(Temporazy Dead Zone)
- 変数の宣言ロジック
1. 処理がスコープに入ると、処理内のlet, const宣言を先に検知し、同名変数参照時に外部を参照しなくなる(TDZ)
2. 処理が宣言行に移ると始めて初期化される
- この1と2の間で先に変数を呼び出してしまうと、外部に同名変数があったとしても参照されずエラーになる
- コード例
```js
let a = 1;
function fn1() {
  // let a = 2;
  console.log(a);
  let a = 3;
}
fn1();

```
### 宣言方法
```js
let a = 1, b = 2;
let [c, d] = [1, 2];

const obj = {prop: 1};
let {prop} = obj;
```

## Object
### プリミティブ型
| データ型         | リテラル例                           | 説明                                                                                       |
|------------------|-------------------------------------|------------------------------------------------------------------------------------------|
| 数値型 (Number)   | 42, 3.14, NaN, Infinity            | 整数や浮動小数点数を表す。特殊値`NaN`や`Infinity`も含む。                                     |
| 文字列型 (String) | 'hello', "world"                   | テキストデータを表す。文字列は`''`または`""`で囲む。                                           |
| 真偽値型 (Boolean)| true, false                        | 真(`true`)または偽(`false`)の論理値を表す。                                                    |
| 未定義型 (Undefined) | undefined                         | 値が割り当てられていないことを示す。                                                         |
| Null型 (Null)     | null                               | 意図的に値が存在しないことを表す。                                                           |
| シンボル型 (Symbol)| Symbol('id')                      | ユニークな識別子を生成するための型。主にオブジェクトのプロパティキーとして利用。                 |
| ビッグイント型 (BigInt) | 123n, BigInt(123)                | 任意の大きさの整数を表す型。`n`を末尾に付けることで表現。                                       |

### オブジェクト型
#### 関数
- 後述
#### 配列

### 真偽値(truthy, falsy)
- falsy
  - `false`
  - `0`
  - `0n`
  - `null`
  - `undefined`
  - `NaN`

#### オブジェクト型(Json)
##### 基本操作
```js
// 宣言
let obj = {
  prop1: 'value',
  prop2: function() {
    console.log('prop2');
  }
};

// プロパティへのアクセス
obj.property; obj['property'];

```

## 関数オブジェクト
### 種類
| 定義の仕方の俗称       | ホイスティング | スコープ              | thisの扱い                 | 記述方法                         |
|------------------------|---------------|-----------------------|----------------------------|----------------------------------|
| 関数宣言 (Function Declaration) | yes           | 関数スコープ/ブロックスコープ | 呼び出し方に応じて変化          | `function 名称(引数) {...}`      |
| 関数式 (Function Expression)   | no            | 関数スコープ/ブロックスコープ | 呼び出し方に応じて変化          | `const 名称 = function(...) {...}` |
| アロー関数 (Arrow Function)     | no            | 関数スコープ/ブロックスコープ | 定義時の親スコープに固定         | `const 名称 = (...) => {...}`    |
| メソッド (Method)              | no            | オブジェクト内で有効         | 呼び出し元のオブジェクトを参照   | `{ メソッド名(...) {...} }`       |
| ジェネレーター関数 (Generator Function) | yes           | 関数スコープ/ブロックスコープ | 呼び出し方に応じて変化          | `function* 名称(...) { yield ... }` |
| 即時実行関数 (IIFE)            | no            | 関数スコープ                | 呼び出し元に依存しない           | `(function(...) {...})();`       |

### 基本仕様
#### 引数と戻り値
- 引数
  - 優先順位: `[[BoundArguments]]` > 呼び出し時に渡された値 > デフォルト値 > `undefined`
  - 超過分: 無視される(argumentsに保管される)
  - 不足分: エラーにはならず`undefined`が代入される
  - デフォルト値の設定が可能
    - undefinedが渡された時のみ、デフォルト値が優先される
- 戻り値を設定しない場合、undefinedが返る
#### 関数もオブジェクト
- jsでは関数がオブジェクトとして扱われる
  - その為、通常のオブジェクト同様、変数に入れたり、プロパティを設定したりする事が可能
    - `function a`を定義すると、`a`という関数型のオブジェクトでありながら`a()`という関数として定義される
  - 通常のオブジェクト型との違い
    - prototype, call, constructなどの予約識別子がある
    - 実行可能(()を付けると実行する)
- 関数の状態の保持が可能
  - 関数内で定義した変数等がそのまま保存される 
  - 例
```js
function incrementFactory() {
  let count = 0;
  this.increment = function() {
    count++;
    return count;
  }
  return this.increment;
}
const counter = incrementFactory();
counter()
```
- 内部関数は、外部関数が実行されるまで生成されない
  - この仕様と、関数自体をオブジェクトとして渡せる仕様を利用して、動的関数の生成が可能
  - [例](./dynamicFunction.js)
### 予約語
#### this/bind/call+apply
- `this`
  - 関数内で動的に値が決定する特殊な識別子
    - 後述の`[[BoundThis]]`が定義されている場合は、その値で固定される
    - 通常時は、メソッド呼び出し時に`this`の値が呼び出し元(トップレベルだとグローバルオブジェクト)に再定義される
    - アロー関数の場合は上記の処理が遮断され、関数定義時の`this`の値で固定される(`[[BoundThis]]`関係なく固定)
  - **ECMScript外のWebApis等の関数では一部動作が変わるから注意**
  - `[[BoundThis]]`はECMAScriptで定義されている隠しメカニズムのため、後述の`bind`以外で操作不可
- `bind()`
  - 関数から呼び出して、呼び出し元に以下を加えた関数を返す(破壊的な変更はされない)
  - 第一引数を、`[[BoundThis]]`に定義
  - 第二引数以下を、`[[BoundArguments]]`に定義
- `call()`
  - 第一引数を`[[BoundThis]]`に定義、第二引数を普通の引数として呼び出し元の関数を実行
    - 既に`[[BoundThis]]`がある場合は、第一引数は無視される
  - `apply`というは`call`の第二引数以下をまとめて配列で指定して、呼び出し元で展開するバージョンがあるが、こちらはスプレッド演算子とほぼ同じ挙動でやや非推奨
- `[[BoundThis]]`にプリミティブ型を渡すとラップが起こる

| 引数 | BountThisの中身 |
|----|----|
| obj(通常, 関数, 配列) | 引数そのまま |
| プリミティブ型 | オブジェクト型{型: 値}にラップされる 例: {String: 'a'} |
| プリミティブ型(null, undefined) | strictによって変わる |

#### 一覧
| 名称           | 説明                                                                 |
|----------------|----------------------------------------------------------------------|
| プロパティ           |                                                                  |
| `length`       | 関数が受け取る引数の数を返す（デフォルト値）。                          |
| `name`         | 関数の名前を返す。匿名関数の場合は空文字列。                             |
| `prototype`    | 関数がコンストラクタとして使用される際に、新しいオブジェクトに継承されるプロパティを持つ。 |
| メソッド          |                                                                  |
| `[[Call]]`    | 関数が呼び出された際の動作を規定する内部メソッド。                        |
| `[[Construct]]` | `new`キーワードを使用した場合に実行される内部メソッド。                    |
| prototype定義識別子                |                                                               |
| `apply`             | 関数を指定した`this`と引数で実行する（`Function.prototype`のメソッド）。 |
| `bind`              | `this`を固定した新しい関数を返す（`Function.prototype`のメソッド）。     |
| `call`              | 関数を指定した`this`と引数で即座に実行する（`Function.prototype`のメソッド）。 |
| 特殊識別子                |                                                                 |
| `arguments`         | 呼び出し時の全引数を配列風オブジェクトで保持（非推奨: アロー関数では利用不可、rest parametersの下位互換）。 |
| `this`              | 呼び出し元に応じて異なる参照先を持つ特別な識別子。                       |

### 特殊なコンストラクタ
- `String`, `Function`などもJsではコンストラクタ関数扱い
- `Function`コンストラクタは、常にグローバルスコープを参照する特別スコープ扱い

### 詳細 / 応用
#### アロー関数
- 基本的には無名関数の省略形として使われる
- this, arguments, new, prototype等の関数の予約識別子が使えない
#### 即時関数
- 目的は処理のスコープを区切って、さらにその処理に戻り値を付ける事
- 現在スコープを区切りたい時は、ファイルを変えてモジュールにすることが推奨されるため、わざわざファイルを分けたくないケースでのみ使われる
#### コールバック関数
- 関数に関数を渡す
```js
function callback() {
  console.log('call backed');
}
function fn(cb) {
  cb()
}

fn(callback);
```

## Prototype
- 関数型は特殊プロパティ`prototype`を持つ、この参照先はインスタンス化を行う際、後述の`__proto__`に参照先がコピーされる
- 全ての値は、特殊プロパティ`__proto__`を持つ、この参照先に定義されているプロパティは、`__proto__`を持つプロパティからも呼び出せる
- Jsでは`String`等は関数(コンストラクタ)扱い、そして文字列等はコンストラクタ関数`String`からインスタンス化した値扱い
  - つまり `'a'.__proto__ === String.prototype`
- 非推奨だが、一応再定義可能
- あくまでコピーするのは参照情報のため、メモリのオーバーヘッドを防げる

## 演算子
### 基本演算子
- Jsの演算子では、暗黙的な型変換を行うため注意が必要
```js
'5' == 5 // true
'5' === 5 // false
```

### 特殊演算子 / 特殊キーワード
| 名前            | 説明                                                    | 例                         | 分類               |
|------------------|--------------------------------------------------------|----------------------------|--------------------|
| typeof           | 変数や値の型を返す                                      | typeof "hello" → "string" | 演算子 (operator)  |
| delete           | オブジェクトのプロパティを削除する                       | delete obj.prop           | 演算子 (operator)  |
| void             | 式を評価して`undefined`を返す                          | void 0                    | 演算子 (operator)  |
| instanceof       | オブジェクトが特定のクラスかを確認する                  | obj instanceof Array      | 演算子 (operator)  |
| in               | プロパティがオブジェクトに存在するか確認                | "key" in obj              | 演算子 (operator)  |
| new              | コンストラクタ関数から新しいオブジェクトを生成          | new Date()                | キーワード         |
| this             | 現在の実行コンテキストを参照                           | this.value                | キーワード         |
| super            | 親クラスや親オブジェクトのメソッドやプロパティにアクセス | super.method()            | キーワード         |

### 詳細
#### new演算子
- 処理順
1. 空のオブジェクトを生成して、その__proto__の参照先を関数.prototypeの参照先とする
2. それを呼び出し元として(thisとして)関数を実行
3. 戻り値がプリミティブ型: 上記のthisとして使用していたオブジェクト, 戻り値がオブジェクト型: 戻り値、を返す
- 以下のコードとやっている事は同じ
```js
function new(C, ...args) {
    const _this = Object.create(C.prototype);
    const result = C.apply(_this, args);
    console.log(typeof result);
    if(typeof result === "object" && result !== null) {
        return result;
    }

    return _this;
}
```
#### typeof, instanceof
- それぞれ、データ型、protoの参照先を検証
- `typeof`は通常コードでは再現できない、`instanceof`は`C.prototype === obj.__proto__`
- プリミティブ型も`__proto__`が使えるため、`instanceof`も使用できるが、typeofで書くのが一般的
- オブジェクト型は当然ながら、typeofは全てObjectになってしまうため、`incetanceof`で判断



# Debug
## デバッガの機能
- break pointの設定
  - 条件付きで設定することもできる
- watch pointの設定: 特定の変数の監視
- step操作
  - `Resume Script Execution`: 停止中のスクリプトを再開。
  - `Step Over`: 現在の行を実行し、次の行に進む。関数の中には入らない。
  - `Step Into`: 現在の行が関数呼び出しの場合、その関数の中に入る。
  - `Step Out`: 現在の関数を抜けて、呼び出し元に戻る。
- コールスタックちゃScopeの変数等の表示